Autenticacion para la Rest API

Podemos proteger solo las rutas que nos interesa no nesesariamente todas
Al ejecutar el comando de:
    php artisan install:api
No solo expuso el archivo api.php sino que tambien nos instala Sanctum que nos permite
hacer la proteccion de las rutas y para eso tenemos varias maneras:
    - SPA Authentication: La mas facil, esta nos ofrece una autenticacion mediante sesion
                          Se recomiendo usarla donde la aplicacion SPA este en el mismo dominio
                          que la aplicacion en Laravel (Front y backend tenemos en el mismo dominio)
    - Api Tokens: Requiere mas configuraciones, donde se crea el token de autenticacion donde en base
                  a un criterio que usualmente es usuario y contrasena se obtiene el usuario regisrado
                  y a apartir de ahi creamos un token que retornamos al fronted, a medida que vayamos
                  consumiento recursos que son protegidos se tiene que mandar el Token

Entonces nos va a interesar proteger recursos de nuestra API y para eso usamos el esquema 
de Sanctum, anteriormente usabamos Breeze para proteger las rutas pero esto es para la aplicacion
web tradicional y Sanctum es para la Rest API

En este caso vamos a empezar primero con el esquema de SPA y despues veremos el de Token

SPA Autenticacion:
    En la parte del app.php colocamos el middleware que nos permite esa proteccion, se requiere usar CQRS 
    si tenemos otros dominios y en el archivo de bootstrap.js tenemos que habilitar la proteccion

Este proyecto se creo nuevo y no tenemos un sistema de autenticacion pero el anterior al instalar breezer ya automaticamente 
nos creo un modulo de login entonces si tubieramos ese esquema podriamos utilizar ese panel de autenticacion
como no lo tenemos entonces vamos a crearlo nosotros para eso tenemos el paquete de "Laravel Fortify" o Breeze o crear una 
funcion nosotros mismos (Lo importante es crear la sesion con el usuario autenticado)

En este caso implementamos el login de manera manual y asi no instalamos paquetes que nos instalaran muchas otras dependencias
Creamos el archivos como controlador:
    php artisan make:controller LoginController
Para probar esto creamos un usuario con Tinker:
    php artisan tinker

        Creamos la instancia del usuario: 
            $user = new App\Models\User()
        Le establecemos la Data: 
            $user->password=Hash::make('12345')
            $user->email='admin@admin.com'
            $user->name='admin'
        Lo guardamos:
            $user->save()

Ahora implementamos el LoginController de manera manual pero hay cosas que como las implementamos al inicio
no van a funcionar
Si hacemos varias peticiones con postman:
    - No vamos a poder establecer la sesion ya que en este caso dentro del IF, estamos accediendo a la session
      esto tiene sentido porque las rutas de la API es para crear una API Rest y por definicion, una API REST
      es sin estado (No es que sea un regla definitiva y no la podamos cambiar), el estado seria la sesion
      Entonces POSTMAN nos da error porque la sesion no esta definida ya que no esta cargado ese milddware en las Rutas de la API
Si intentamos consumir la ruta que creamos en "WEB.php":
    - En postman veremos un error de 419, este error hace referencia al token CSRF que por defecto se encuentran activas para el modulo de 
      Router de VUE que definimos antes, aparte de que tenemos otro problema en el que dentro del LoginController cuando no es valido se nos
      redirecciona a la pagina anterior que en este caso no existe si es la pagina de WELCOME
Como postman es solo para pruebas entonces vamos nosotros a consumir desde el codigo que seria el metodo de "Authentication" para
ver si esta funcionando y luego consumir una ruta protegida como la de "middleware('auth:sanctum')" que esta en "API.php" es decir primero
debemos de estar autenticados para emplear todo esto
Para esto vamos a tener que emplear un Endpoint '/sanctum/csrf/cookie' que seria una sesion que esta simulando SANCTUM que inicializa la proteccion
CSRF y de ahi ya podemos probar el LOGIN

Aqui usamos la proteccion con Sanctum especificamente agregandole el middleware, especificando que rutas queremos proteger

Ahora vamos a utilizar los Tokens de autenticacion
Vamos a crear un controlador para el usuario que lo vamos a hacer por cuestiones de tener organizado el proyecto
ya que el LoginController lo podemos usar para otras situaciones pero en los Tokens ya tiene mas coneccion con el API REST
Ademas que realizamos algunas otras  modificaciones

        CACHE

Es un sistema de almacenamiento rapido y mejor al desesmpeÃ±o al tener que acceder a cada rato solo que su capacidad
es poca, usualmente es su uso en las peticiones HTTP, aqui hay varios aspectos que se podrian mejorar por ejemplo el uso de la conexion 
a la base de datos que es algo lento, la cache la podemos usar para agilizar una peticion evitando que la app entre a la BD

Tenemos varios tipos de almacenamiento
    * Redis: Motor de base de datos clave y valor rapido, se emplea para trabajar con la cache

Tambien si se actualiza o borra algo de la informacion que esta en la cache tambien tenemos que ejecutar estas acciones dentro de la cache

Hay algunas tecnicas en la que se configura para que la cache tenga solo cierto tiempo de duracion
En la cache podemos almacenar cualquier cosa que sea un Texto o Contenido 

En Laravel tenemos el Cache de Rutas
    En este caso se genera un archivo temporal en la cual se accede a ese archivo cada vez que nosotros accedamos a una ruta en particular
    en vez de escanear todo el archivo 

Uso Basico de la Cache:
    Con la cache en laravel tenemos distintos metodos y opciones que podemos utilizar para adaptarlo a distintos esquemas: (Recordemos que la cache trabaja con
    el clave y valor, por ejemplo para almacenar el contenido de una pagina para la clave tiene sentido que sea el URL de la pagina o el SLUG), estos metodos se acceden
    con el Facade "Cache::NombreDelMetodo"
        * get() -> Recuperar el contenido segun la key que le pasemos o si no queremos que nos regres null le podemos especificar un valor por defecto
        * has() -> Nos regresa un booleano y sirve para determinar si un elemento existe en la cache o no
        * put() -> Se le manda la Clave, Duracion de la cache, Los datos que se van a almacenar
        * putMany() -> Es como el put pero permite almacenar un Array De dato
        * add() -> Solo agrega el elemento en la cache si no existe y nos regresa un booleano si tuvo exito en el almacenamiento o no
        * pull() -> Obtener un elemento y luego se elimina de la cache
        * many() -> Recuperar multiples datos obteniendolos en un Array
        * remember() -> Verifica si los datos existen en la cache y en caso de no existir podemos definir una logica para resolver la operacion del cliente definiendo
                        lo que se va almacenar en la cache y se regresa como respuesta
        * rememberForever() -> Hace lo mismo que arriba pero en este no se le pasa la duracion asi que almacena el contenido para siempre
        * increment() -> Para incrementar contenido numerico 
        * decrement() -> Decremantar el contenido numerico
        * forever() -> Es como el de PUT() pero no se le pasa la duracion ya que es para siempre
        * forget() ->  Elimina un elemento
        * flush() -> Eliminar todos los elementos de la cache

El ejercicio que vamos a hacer:
    * Consultar primero si tenemos algo en la cache, si es asi retornamos lo que tengamo ahi
        Si no tenemos nada es ir a la vista y con esto vamos a la BD para buscar el contenido, procesar la vista
        y luego devolverla
        (Esto se implemento en el BlogController)

    El ejercicio le correspondia aplicarlo en el Proyecto de laravel de fronted

Esta practica si va en el proyecto de laravel de Rest Api
    * Con has preguntamos si existe en la cache, donde si es el caso regresamos el contenido
        si no existe hace la consulta en la BD, se insrta en la cache y se muestran los datos al usuario
    * Si queremos guardar la respuesta en JSON y resulta que tiene muchos registros nos puede dar una excepcion
        * Allowed memory size of: 536870912 bytes exhausted
      Esto pasa por superar la cantidad de memoria permitida, como solucion si queremos guardar la repuesta directamente en JSON
      es primero preguntar si no tenemos la cache y si es no entonces se almacenan primero los datos en la variable convertidos a JSON
      y esa variable es la que se retorna

Cache de las Rutas
    Para que en vez que cada vez que se realiza una peticion laravel lea la cache de las rutas y se ejecuten proceso adicionales
    se optimicen estas actividades 
    Originalemnte se lee cada vez el archivo web y cada vez que se cree una ruta ahi, automaticamente se va a cargar o reflejar en la aplicacion
    pero cuando se crea el cache de las rutas eso no sucede
    Tenemos los comandos:
        - php artisan route:cache -> Guardar el cache de las rutas para que luzcan tal cual esta definida en el momento que se ejecuta este comando
        - php artisan route:clear -> Laravel ahora comparara las rutas con el archivo generado en lugar de los archivos reales usados para las rutas, 
                                     por lo tanto si realiza cambios en las rutas se ejecuta este comando para limpiar los archivos del cache de las rutas 
    
        Gate y Politicas (Autorizacion)

    Con esto agregamos permisos sobre que acciones puede realizar un determinado usuario, seria como los roles y permisos pero mas enfocado a las entidades como 
    el usuario por ejemplo que tipo de usuarios pueden acceder a ciertas partes de la pagina
        * En este caso vamos a crear un nuevo campo para la entidad de los post que corresponde al userID por lo tanto para que un usuario pueda editar o eliminar
        tiene que haber creado ese post (Esta es la regla para ese ejemplo)

    Autenticacion: Hace referencia cuando el usuario presenta sus credenciales (Usuario y contrasena) y realiza el Login

    Autorizacion: Aqui es donde defenimos nuestras reglas para que decidir si cierto usuario puede ver o no cierto recurso segun el ROL que tenga el usuario
        Para el manejo de la Autorizacion tenemos el uso de los Gate y de las Politicas, la diferencia es que los Gates son funciones y las politicas son clases que
        por tanto tenemos mayor control y orden pero a la final ambos determinan las reglas de accesso

        El Gate lo podriamos usar para especificar una regla corta pero ya para algo mas complejo con multiples reglas de autorizacion seria una Politica
        en la Politica tendremos una clase con sus metodos de Update, Create, Delete, estos metodos se mandan a llamar automaticamente cuando en el post se 
        intenta realizar alguna de estas operaciones

    Preparacion del proyecto:
        Ahora los post van a pertenecer a un usuario y solo el creador podra eliminarlo o modificarlo
        - Primero definimos una nueva columna para las publicaciones y que un post pertenesca a un usuario
            * Creamos una nueva migracion y en el nombre especificamos que vamos a agreagr la columna "user_id" a la tabla "post"
                - php artisan make:migration add_user_id_to_posts_table
            * Despues de ejecutar ese comando tenemos el archivo para especificar la creacion de la columna
              - El problema es que si despues ejecutamos el comendo para migrar es que ya tenemos en la BD varias publicaciones y la columna de "user_id" no va a ser nula
                por lo tanto va a ver problemas con los datos actuales asi que podemos ir a la BD y eliminar todos los registros en la tabla de Posts
            - Tambien podemos ejecutar:
                * php artisan migrate:fresh 
              Lo que hace es eliminar toda las migraciones, borrar todos los datos y luego volver a ejecutar las migraciones
        - Con esto ya tenemos la columna "user_id" en la tabla de Posts

    Despues de la modificacion de los archivos ejecutamos
        - php artisan db:seed -> Con esto generamos datos
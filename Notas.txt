Autenticacion para la Rest API

Podemos proteger solo las rutas que nos interesa no nesesariamente todas
Al ejecutar el comando de:
    php artisan install:api
No solo expuso el archivo api.php sino que tambien nos instala Sanctum que nos permite
hacer la proteccion de las rutas y para eso tenemos varias maneras:
    - SPA Authentication: La mas facil, esta nos ofrece una autenticacion mediante sesion
                          Se recomiendo usarla donde la aplicacion SPA este en el mismo dominio
                          que la aplicacion en Laravel (Front y backend tenemos en el mismo dominio)
    - Api Tokens: Requiere mas configuraciones, donde se crea el token de autenticacion donde en base
                  a un criterio que usualmente es usuario y contrasena se obtiene el usuario regisrado
                  y a apartir de ahi creamos un token que retornamos al fronted, a medida que vayamos
                  consumiento recursos que son protegidos se tiene que mandar el Token

Entonces nos va a interesar proteger recursos de nuestra API y para eso usamos el esquema 
de Sanctum, anteriormente usabamos Breeze para proteger las rutas pero esto es para la aplicacion
web tradicional y Sanctum es para la Rest API

En este caso vamos a empezar primero con el esquema de SPA y despues veremos el de Token

SPA Autenticacion:
    En la parte del app.php colocamos el middleware que nos permite esa proteccion, se requiere usar CQRS 
    si tenemos otros dominios y en el archivo de bootstrap.js tenemos que habilitar la proteccion

Este proyecto se creo nuevo y no tenemos un sistema de autenticacion pero el anterior al instalar breezer ya automaticamente 
nos creo un modulo de login entonces si tubieramos ese esquema podriamos utilizar ese panel de autenticacion
como no lo tenemos entonces vamos a crearlo nosotros para eso tenemos el paquete de "Laravel Fortify" o Breeze o crear una 
funcion nosotros mismos (Lo importante es crear la sesion con el usuario autenticado)

En este caso implementamos el login de manera manual y asi no instalamos paquetes que nos instalaran muchas otras dependencias
Creamos el archivos como controlador:
    php artisan make:controller LoginController
Para probar esto creamos un usuario con Tinker:
    php artisan tinker

        Creamos la instancia del usuario: 
            $user = new App\Models\User()
        Le establecemos la Data: 
            $user->password=Hash::make('12345')
            $user->email='admin@admin.com'
            $user->name='admin'
        Lo guardamos:
            $user->save()

Ahora implementamos el LoginController de manera manual pero hay cosas que como las implementamos al inicio
no van a funcionar
Si hacemos varias peticiones con postman:
    - No vamos a poder establecer la sesion ya que en este caso dentro del IF, estamos accediendo a la session
      esto tiene sentido porque las rutas de la API es para crear una API Rest y por definicion, una API REST
      es sin estado (No es que sea un regla definitiva y no la podamos cambiar), el estado seria la sesion
      Entonces POSTMAN nos da error porque la sesion no esta definida ya que no esta cargado ese milddware en las Rutas de la API
Si intentamos consumir la ruta que creamos en "WEB.php":
    - En postman veremos un error de 419, este error hace referencia al token CSRF que por defecto se encuentran activas para el modulo de 
      Router de VUE que definimos antes, aparte de que tenemos otro problema en el que dentro del LoginController cuando no es valido se nos
      redirecciona a la pagina anterior que en este caso no existe si es la pagina de WELCOME
Como postman es solo para pruebas entonces vamos nosotros a consumir desde el codigo que seria el metodo de "Authentication" para
ver si esta funcionando y luego consumir una ruta protegida como la de "middleware('auth:sanctum')" que esta en "API.php" es decir primero
debemos de estar autenticados para emplear todo esto
Para esto vamos a tener que emplear un Endpoint '/sanctum/csrf/cookie' que seria una sesion que esta simulando SANCTUM que inicializa la proteccion
CSRF y de ahi ya podemos probar el LOGIN

Aqui usamos la proteccion con Sanctum especificamente agregandole el middleware, especificando que rutas queremos proteger

Ahora vamos a utilizar los Tokens de autenticacion
Vamos a crear un controlador para el usuario que lo vamos a hacer por cuestiones de tener organizado el proyecto
ya que el LoginController lo podemos usar para otras situaciones pero en los Tokens ya tiene mas coneccion con el API REST
Ademas que realizamos algunas otras  modificaciones

        CACHE

Es un sistema de almacenamiento rapido y mejor al desesmpeÃ±o al tener que acceder a cada rato solo que su capacidad
es poca, usualmente es su uso en las peticiones HTTP, aqui hay varios aspectos que se podrian mejorar por ejemplo el uso de la conexion 
a la base de datos que es algo lento, la cache la podemos usar para agilizar una peticion evitando que la app entre a la BD

Tenemos varios tipos de almacenamiento
    * Redis: Motor de base de datos clave y valor rapido, se emplea para trabajar con la cache

Tambien si se actualiza o borra algo de la informacion que esta en la cache tambien tenemos que ejecutar estas acciones dentro de la cache

Hay algunas tecnicas en la que se configura para que la cache tenga solo cierto tiempo de duracion
En la cache podemos almacenar cualquier cosa que sea un Texto o Contenido 

En Laravel tenemos el Cache de Rutas
    En este caso se genera un archivo temporal en la cual se accede a ese archivo cada vez que nosotros accedamos a una ruta en particular
    en vez de escanear todo el archivo 

Uso Basico de la Cache:
    Con la cache en laravel tenemos distintos metodos y opciones que podemos utilizar para adaptarlo a distintos esquemas: (Recordemos que la cache trabaja con
    el clave y valor, por ejemplo para almacenar el contenido de una pagina para la clave tiene sentido que sea el URL de la pagina o el SLUG), estos metodos se acceden
    con el Facade "Cache::NombreDelMetodo"
        * get() -> Recuperar el contenido segun la key que le pasemos o si no queremos que nos regres null le podemos especificar un valor por defecto
        * has() -> Nos regresa un booleano y sirve para determinar si un elemento existe en la cache o no
        * put() -> Se le manda la Clave, Duracion de la cache, Los datos que se van a almacenar
        * putMany() -> Es como el put pero permite almacenar un Array De dato
        * add() -> Solo agrega el elemento en la cache si no existe y nos regresa un booleano si tuvo exito en el almacenamiento o no
        * pull() -> Obtener un elemento y luego se elimina de la cache
        * many() -> Recuperar multiples datos obteniendolos en un Array
        * remember() -> Verifica si los datos existen en la cache y en caso de no existir podemos definir una logica para resolver la operacion del cliente definiendo
                        lo que se va almacenar en la cache y se regresa como respuesta
        * rememberForever() -> Hace lo mismo que arriba pero en este no se le pasa la duracion asi que almacena el contenido para siempre
        * increment() -> Para incrementar contenido numerico 
        * decrement() -> Decremantar el contenido numerico
        * forever() -> Es como el de PUT() pero no se le pasa la duracion ya que es para siempre
        * forget() ->  Elimina un elemento
        * flush() -> Eliminar todos los elementos de la cache

El ejercicio que vamos a hacer:
    * Consultar primero si tenemos algo en la cache, si es asi retornamos lo que tengamo ahi
        Si no tenemos nada es ir a la vista y con esto vamos a la BD para buscar el contenido, procesar la vista
        y luego devolverla
        (Esto se implemento en el BlogController)

    El ejercicio le correspondia aplicarlo en el Proyecto de laravel de fronted

Esta practica si va en el proyecto de laravel de Rest Api
    * Con has preguntamos si existe en la cache, donde si es el caso regresamos el contenido
        si no existe hace la consulta en la BD, se insrta en la cache y se muestran los datos al usuario
    * Si queremos guardar la respuesta en JSON y resulta que tiene muchos registros nos puede dar una excepcion
        * Allowed memory size of: 536870912 bytes exhausted
      Esto pasa por superar la cantidad de memoria permitida, como solucion si queremos guardar la repuesta directamente en JSON
      es primero preguntar si no tenemos la cache y si es no entonces se almacenan primero los datos en la variable convertidos a JSON
      y esa variable es la que se retorna

Cache de las Rutas
    Para que en vez que cada vez que se realiza una peticion laravel lea la cache de las rutas y se ejecuten proceso adicionales
    se optimicen estas actividades 
    Originalemnte se lee cada vez el archivo web y cada vez que se cree una ruta ahi, automaticamente se va a cargar o reflejar en la aplicacion
    pero cuando se crea el cache de las rutas eso no sucede
    Tenemos los comandos:
        - php artisan route:cache -> Guardar el cache de las rutas para que luzcan tal cual esta definida en el momento que se ejecuta este comando
        - php artisan route:clear -> Laravel ahora comparara las rutas con el archivo generado en lugar de los archivos reales usados para las rutas, 
                                     por lo tanto si realiza cambios en las rutas se ejecuta este comando para limpiar los archivos del cache de las rutas 
    
        Gate y Politicas (Autorizacion)

    Con esto agregamos permisos sobre que acciones puede realizar un determinado usuario, seria como los roles y permisos pero mas enfocado a las entidades como 
    el usuario por ejemplo que tipo de usuarios pueden acceder a ciertas partes de la pagina
        * En este caso vamos a crear un nuevo campo para la entidad de los post que corresponde al userID por lo tanto para que un usuario pueda editar o eliminar
        tiene que haber creado ese post (Esta es la regla para ese ejemplo)

    Autenticacion: Hace referencia cuando el usuario presenta sus credenciales (Usuario y contrasena) y realiza el Login

    Autorizacion: Aqui es donde defenimos nuestras reglas para que decidir si cierto usuario puede ver o no cierto recurso segun el ROL que tenga el usuario
        Para el manejo de la Autorizacion tenemos el uso de los Gate y de las Politicas, la diferencia es que los Gates son funciones y las politicas son clases que
        por tanto tenemos mayor control y orden pero a la final ambos determinan las reglas de accesso

        El Gate lo podriamos usar para especificar una regla corta pero ya para algo mas complejo con multiples reglas de autorizacion seria una Politica
        en la Politica tendremos una clase con sus metodos de Update, Create, Delete, estos metodos se mandan a llamar automaticamente cuando en el post se 
        intenta realizar alguna de estas operaciones

    Preparacion del proyecto:
        Ahora los post van a pertenecer a un usuario y solo el creador podra eliminarlo o modificarlo
        - Primero definimos una nueva columna para las publicaciones y que un post pertenesca a un usuario
            * Creamos una nueva migracion y en el nombre especificamos que vamos a agreagr la columna "user_id" a la tabla "post"
                - php artisan make:migration add_user_id_to_posts_table
            * Despues de ejecutar ese comando tenemos el archivo para especificar la creacion de la columna
              - El problema es que si despues ejecutamos el comendo para migrar es que ya tenemos en la BD varias publicaciones y la columna de "user_id" no va a ser nula
                por lo tanto va a ver problemas con los datos actuales asi que podemos ir a la BD y eliminar todos los registros en la tabla de Posts
            - Tambien podemos ejecutar:
                * php artisan migrate:fresh 
              Lo que hace es eliminar toda las migraciones, borrar todos los datos y luego volver a ejecutar las migraciones
        - Con esto ya tenemos la columna "user_id" en la tabla de Posts

    Despues de la modificacion de los archivos ejecutamos
        - php artisan db:seed -> Con esto generamos datos

    Uso de los Gate

        Lo mismo que podemos emplear con los Gate, lo podemos hacer con los condicionales, Los Gates son Facades que implementan varios metodos
        para poder usarlo lo registramos en el archivo AppServiceProvider (Aqui se definen las reglas que vamos a definir)
        Con el metodo "definie" le pasamo un Key como identificador unico, despues recibe una funcion el cual recibe siempre el usuario autentica ya que las reglas tienen
            relacion directa con el usuario autenticado, el resto de los argumento depende de nuestra nesecidades, dentro de la funcion creamos la regla que queremos evaluar
            (En este caso sera que el Post pertenesca al usuario autenticado)
        Dentro de ese archivo podemos definir tantos Gates como queramos y solo los invocamos, la ganancia de usar un Gate en lugar de un condicional es que nos evitamos agreagr
        logica adicional al controlador
        Al invocar el gate solo le pasaremos los argumentos adicionales no el usuario ya que eso lo hace automaticamente Laravel por nosotros

    Uso de las Politicas

        A diferencia de los Gate en los que tenemos que definir todas las reglas en un solo archivo, con las politicas lo podemos hacer mas modular definiendolo en un archivo aparte 
        Para esto tenemos el siguiente comando:
            - php artisan make:policy PostPolicy -> Lo que es "PostPolicy" contiene el prefico "Post" del modelo con el que vamos a trabajar, con esto ademas hacemos que laravel
                                                    ya sepa cual modelo es el que tiene que usar  
            - Si no le especificamos correctamente el prefijo tenemos que especificarlo en el mismo comando:
                php artisan make:policy PostPolicy --model=Post
        Despues tenemos acceso a los mismos metodos con los que tenemos acceso a los Gate
        Dentro de las funciones de la clase que nos genera Laravel veremos que estaremos recibiendo el usuario al igual que en los Gates (Con este usuarios preguntamos los datos que requiramos)
        en seguida le colocamos la entidad con la cual queramos definir las reglas
        Dentro de las funciones que nos genera estan:
            - viewAny() -> Es como un before el cual se va a ejecutar antes de cualquiera de las otras reglas que definamos 
            - view() -> Este es como el metodo Show que teniamos en el CRUD
            - Crear, Actualizar y Eliminar

        En pocas palabras las politicas son los Gates pero en un archivo aparte para tener todos mas modular

        Despues de creados nuestras reglas en el PostPolicy ahora la podemos usar
            Solo colocamos el nombre del metodo que queremos emplear (Esto lo hacemos en "PostController")

        Respuestas de las politicas 
            No estamos obligados a regresar un booleano, ya que tambien podemos regresar una Respuesta HTTP, de ahi tenemos metodos "allow()" y para denegar como "deny()"
            Esto es para no mostrarle al usuario solo un carte de FORBIDDEN ya que tambien le podemos dar un mensaje

        Vamos a modificar la relacion de usuarios para que tambien podamos ver los Post de los usuarios y esto lo haremos con el proposito para que cuando guardemos el POST lo
        podamos hacer desde la relacion de usuarios de tal forma que no tenemos que moificar el Request para exponer todos los campos e inyectarle el UserID sino que solo lo hacemos
        usando la entidad del usuario 

    Metodos Importantes:
        * Gate::check() -> Este condicional solo se ejecuta si el usuario tiene permisos de crear el Post
        * Gate::any() -> Se ejecuta si el usuario tiene al menos uno de los permisos que le estamos indicando 
        * Gate::none() -> Solo se ejecuta si el usuario no puede actualizar o eliminar (Si no tiene esos u otros permisos)
        * Gate::can() -> Se ejecuta si el usuario tiene el permiso indicado
                         Este se pregunta sobre el usuario autenticado:
                            auth()->user()->can('create', $post);
        * Gate::canot() -> Se ejecuta si el usuario no tiene el permiso
        * Gate::forUser() -> Si queremos preguntar para un usuario en particular que no tiene que ser el usuario autenticado (Con este podemos ver que permisos tiene cada usuario para cierta pagina)
        * Gate::allowIf() -> Muchas veses queremos realizar alguna condicion sin defenir un Gate para ello podemos usar este metodo permitiendo si la condicion es True, asi no definmos el Gate sino que solo
                             la definimos directamente en el controlador
                             Como Ejemplo de la implementacion:
                                (Aqui colocamos dentro de la funcion tanto la regla que vamos a usar y de una vez nos bloque si no tenemos permisos )
                                Gate::allowIf(fn(User $user) => $user->id > 0);
        * Gate::denyIf() -> Esto es lo contrario de lo arriba
        * Gate::authorize() -> Por una parte intenta autoriza la accion y si no la permite lanza una excepcion automaticamente (Seria como el mensaje del Response que vimos anteriormente)
          
        Metodo Before:
            Se ejecutara antes que cualquier otro metodo de politica con esto se puede realizar configuraciones comunes para todas las funciones definidas en la Politica
            

    Roles y Permisos (Spatie)

        Para esto vamos a emplear un paquete de tercero llamado "Spatie", esto viene siendo como una extencion de las Politicas y Gate, en cualquier sistema tener un Rol significa tener asignado los permisos
        esto se asigna a los usuarios cada Rol y de esos Roles cada uno tiene Permisos pero igual se pueden asignar Permisos directamente al usuario, Ahora en el Dashboard vamos implementar varias opciones como el de los Roles
        donde se nos mostraran para agregarlos a cada usuario, entre las opciones tendremos el boton de Mostrar para ver todos los permisos asignados donde podemos borrarlos y asignarlos, ademas tendremos las opciones de Permisos
        y Usuarios.

        Aqui el Rol usualemente el enfoque que se le da es para asignar los permisos en grupo a los usuarios pero tambien podemos hacer comprobaciones por el rol que tenga el usuario pero usualmente comparamos los permisos que se asignan
        mediante los roles

        Para este caso tendremos un sistema mas robusto, protegemos ciertos permisos de la aplicacion por ejemplo habilitar las opciones del menu solo para ciertos usuario autenticados que cumplan cierta condicion, entonces tenemos 
        el ROL y de ahi le asignamos los permisos que serian los accesos, por ejemplo para el Rol de administrador que pueda hacer el tipico CRUD
        Para el Editor que solo pueda aplicar el crud a los post creados por el mismo.
        
        En Laravel tenemos varias tecnologias que se pueden juntar ya que con las politicas existia un caso similar si lo comparamos con los Middlewares donde tambien se podia desarrollar para comparar si el usuario esta autenticado
        y con Roles tenemos algo similar donde especificamos que tal usuario tenga un permiso en especifico 

        Aqui se crearn tablas pivotes en las BD donde se almacena que permisos existen en los roles, ya que tenemos un Rol el cual tiene asignados multiples permisos y a su vez un usuario puede tener de 0 a N roles y tambien le 
        podemos asignar permisos de manera directa. Esto lo podemos hacer de varias formas en la que tenemos el Rol y asignarle permisos o podemos tener un permiso y administrarle los roles (Podemos tener la relacion directa o inversa entre 
        permiso y rol)

        Instalacion y Configuracion (Spatie)
            - composer require spatie/laravel-permission
            - php artisan vendor:publish --provider="Spatie\Permission\PermissionServiceProvider"

            Despues de esto tendremos el archivo de configuracion de "Permission.php" y un nuevo archivo en las migraciones donde tenemos las nuevas tablas y las de pivotes 
                - php artisan migrate 

        Seeders (Crear datos de prueba)
            * php artisan make:seeder RoleSeeder

        Despues de creados los Roles y Permisos en "RolSeeder.php", ejecutamos:
            * php artisan db:seed --class=RoleSeeder

        Verificar los Permisos

            Hasta este punto no podemos hacer nada con los Roles y Permisos, solo tenemos los datos guradados en la BD, lo importantes es manejarlo con el usuario solo que el usuario
            no lo hemos metido en nigun proseso, solo fue lo de roles y permisos, todas estas operaciones de aqui solo las podemos hacer con el usuario que es el acceso a los metodos
            para consulta:
                * $user->can('editor.post.update'); -> Con este verificamos si el usuario puede hacer determinada operacion, el "user" lo podemos conseguir de varias maneras como el Request/User, AuthFacadeUser, La funcion de ayuda de Auth()/User
            Lo equivalente del usuario seria el ROL:
                * $rol->hasPermissionTo('editor.post.update'); -> PReguntamos si tiene el permiso especificado
            Aqui preguntamos mediante el Facade si el usuario tiene ciertos ROLes:
                * Auth:user()->hasRole(['Editor', 'Admin']);
            Aqui preguntamos si tiene alguno de los roles
                * Auth:user()->hasAnyRole(['Editor', 'Admin']);
            Si tiene todos los roles, en este caso usamos la operacion a la BD para conseguir todo el listado
                * $user->hasAllRoles(Role::all());
            Desde Blade:
                @can(<PERMISSION>)
                    Accede si tiene Permiso
                @endcan

        Crear CRUD de Roles
            - Crear controlador (Con las operaciones CRUD)
            - Creamos las Rutas
            - Clase Request para validar el nombre
            - Crear Vistas Blade